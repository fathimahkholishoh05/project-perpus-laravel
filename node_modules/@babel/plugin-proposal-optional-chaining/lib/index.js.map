{"version":3,"file":"index.js","sources":["../src/util.ts","../src/transform.ts","../src/index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\nimport { isTransparentExprWrapper } from \"@babel/helper-skip-transparent-expression-wrappers\";\n/**\n * Test if a NodePath will be cast to boolean when evaluated.\n * It respects transparent expression wrappers defined in\n * \"@babel/helper-skip-transparent-expression-wrappers\"\n *\n * @example\n * // returns true\n * const nodePathADotB = NodePath(\"if (a.b) {}\").get(\"test\"); // a.b\n * willPathCastToBoolean(nodePathADotB)\n * @example\n * // returns false\n * willPathCastToBoolean(NodePath(\"a.b\"))\n * @param {NodePath} path\n * @returns {boolean}\n */\nexport function willPathCastToBoolean(path: NodePath): boolean {\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const { node, parentPath } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const { operator, right } = parentPath.node;\n    if (\n      operator === \"&&\" ||\n      operator === \"||\" ||\n      (operator === \"??\" && node === right)\n    ) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const { expressions } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      // if it is in the middle of a sequence expression, we don't\n      // care the return value so just cast to boolean for smaller\n      // output\n      return true;\n    }\n  }\n  return (\n    parentPath.isConditional({ test: node }) ||\n    parentPath.isUnaryExpression({ operator: \"!\" }) ||\n    parentPath.isLoop({ test: node })\n  );\n}\n\n/**\n * Return the outermost transparent expression wrapper of a given path,\n * otherwise returns path itself.\n * @example\n * const nodePathADotB = NodePath(\"(a.b as any)\").get(\"expression\"); // a.b\n * // returns NodePath(\"(a.b as any)\")\n * findOutermostTransparentParent(nodePathADotB);\n * @param {NodePath} path\n * @returns {NodePath}\n */\nexport function findOutermostTransparentParent(path: NodePath): NodePath {\n  let maybeWrapped = path;\n  path.findParent(p => {\n    if (!isTransparentExprWrapper(p.node)) return true;\n    maybeWrapped = p;\n  });\n  return maybeWrapped;\n}\n","import { types as t, template } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport {\n  skipTransparentExprWrapperNodes,\n  skipTransparentExprWrappers,\n} from \"@babel/helper-skip-transparent-expression-wrappers\";\nimport { willPathCastToBoolean, findOutermostTransparentParent } from \"./util\";\n\nconst { ast } = template.expression;\n\nfunction isSimpleMemberExpression(expression) {\n  expression = skipTransparentExprWrapperNodes(expression);\n  return (\n    t.isIdentifier(expression) ||\n    t.isSuper(expression) ||\n    (t.isMemberExpression(expression) &&\n      !expression.computed &&\n      isSimpleMemberExpression(expression.object))\n  );\n}\n\n/**\n * Test if a given optional chain `path` needs to be memoized\n * @param {NodePath} path\n * @returns {boolean}\n */\nfunction needsMemoize(path) {\n  let optionalPath = path;\n  const { scope } = path;\n  while (\n    optionalPath.isOptionalMemberExpression() ||\n    optionalPath.isOptionalCallExpression()\n  ) {\n    const { node } = optionalPath;\n    const childKey = optionalPath.isOptionalMemberExpression()\n      ? \"object\"\n      : \"callee\";\n    const childPath = skipTransparentExprWrappers(optionalPath.get(childKey));\n    if (node.optional) {\n      return !scope.isStatic(childPath.node);\n    }\n\n    optionalPath = childPath;\n  }\n}\n\nexport function transform(\n  path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n  {\n    pureGetters,\n    noDocumentAll,\n  }: { pureGetters: boolean; noDocumentAll: boolean },\n) {\n  const { scope } = path;\n  // maybeWrapped points to the outermost transparent expression wrapper\n  // or the path itself\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const { parentPath } = maybeWrapped;\n  const willReplacementCastToBoolean = willPathCastToBoolean(maybeWrapped);\n  let isDeleteOperation = false;\n  const parentIsCall =\n    parentPath.isCallExpression({ callee: maybeWrapped.node }) &&\n    // note that the first condition must implies that `path.optional` is `true`,\n    // otherwise the parentPath should be an OptionalCallExpression\n    path.isOptionalMemberExpression();\n\n  const optionals = [];\n\n  let optionalPath = path;\n  // Replace `function (a, x = a.b?.c) {}` to `function (a, x = (() => a.b?.c)() ){}`\n  // so the temporary variable can be injected in correct scope\n  if (scope.path.isPattern() && needsMemoize(optionalPath)) {\n    path.replaceWith(template.ast`(() => ${path.node})()` as t.Statement);\n    // The injected optional chain will be queued and eventually transformed when visited\n    return;\n  }\n  while (\n    optionalPath.isOptionalMemberExpression() ||\n    optionalPath.isOptionalCallExpression()\n  ) {\n    const { node } = optionalPath;\n    if (node.optional) {\n      optionals.push(node);\n    }\n\n    if (optionalPath.isOptionalMemberExpression()) {\n      // @ts-expect-error todo(flow->ts) avoid changing more type\n      optionalPath.node.type = \"MemberExpression\";\n      // @ts-expect-error todo(flow->ts)\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"object\"));\n    } else if (optionalPath.isOptionalCallExpression()) {\n      // @ts-expect-error todo(flow->ts) avoid changing more type\n      optionalPath.node.type = \"CallExpression\";\n      // @ts-expect-error todo(flow->ts)\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"callee\"));\n    }\n  }\n\n  let replacementPath: NodePath<any> = path;\n  if (parentPath.isUnaryExpression({ operator: \"delete\" })) {\n    replacementPath = parentPath;\n    isDeleteOperation = true;\n  }\n  for (let i = optionals.length - 1; i >= 0; i--) {\n    const node = optionals[i];\n\n    const isCall = t.isCallExpression(node);\n    const replaceKey = isCall ? \"callee\" : \"object\";\n\n    const chainWithTypes = node[replaceKey];\n    const chain = skipTransparentExprWrapperNodes(chainWithTypes);\n\n    let ref;\n    let check;\n    if (isCall && t.isIdentifier(chain, { name: \"eval\" })) {\n      check = ref = chain;\n      // `eval?.()` is an indirect eval call transformed to `(0,eval)()`\n      node[replaceKey] = t.sequenceExpression([t.numericLiteral(0), ref]);\n    } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {\n      // If we assume getters are pure (avoiding a Function#call) and we are at the call,\n      // we can avoid a needless memoize. We only do this if the callee is a simple member\n      // expression, to avoid multiple calls to nested call expressions.\n      check = ref = chainWithTypes;\n    } else {\n      ref = scope.maybeGenerateMemoised(chain);\n      if (ref) {\n        check = t.assignmentExpression(\n          \"=\",\n          t.cloneNode(ref),\n          // Here `chainWithTypes` MUST NOT be cloned because it could be\n          // updated when generating the memoised context of a call\n          // expression\n          chainWithTypes,\n        );\n\n        node[replaceKey] = ref;\n      } else {\n        check = ref = chainWithTypes;\n      }\n    }\n\n    // Ensure call expressions have the proper `this`\n    // `foo.bar()` has context `foo`.\n    if (isCall && t.isMemberExpression(chain)) {\n      if (pureGetters && isSimpleMemberExpression(chain)) {\n        // To avoid a Function#call, we can instead re-grab the property from the context object.\n        // `a.?b.?()` 